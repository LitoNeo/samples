本文包含以下内容
　　1. C++的四类特殊成员函数介绍，重点介绍拷贝构造函数和拷贝复制运算符
　　2. C++11中的default/delete特性
本文内容侧重个人理解，深入理解其原理推荐[https://www.geeksforgeeks.org](https://www.geeksforgeeks.org/explicitly-defaulted-deleted-functions-c-11/)
## 前言
C++ 的类有四类特殊成员函数，分别是：
* 默认构造函数
* 析构函数 
* 拷贝构造函数
* 拷贝赋值运算符

　　这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。如果没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。
**sample**
```c++
class Test{
    private:
        int _id;

    public:
        Test(int a);  // 构造函数
        Test(const Test& test);  // 拷贝构造函数
        Test& operator=(const Test& test);  // 拷贝赋值运算符
        ~Test();  // 析构函数
}
```
### 构造函数和拷贝构造函数
从名称上也不难理解，`构造函数`和`拷贝构造函数`都是用于进行类实例初始化的
```c++
Test t1(2);  // 调用实参匹配的构造函数
Test t2 = t1;  // 调用拷贝构造函数，用t1对t2进行初始化
```
以上也正是C++类进行初始化的两种方式。

**使用/调用拷贝构造函数的情况**
`拷贝`构造函数的作用主要是复制对象
1. 复制对象，并通过函数返回复制后的对象。
2. 一个对象以`值传递`的方式传入函数，此时必定调用拷贝构造函数，即`void Func(Test test){}`这类。
3. 一个对象以另一个对象为例进行初始化，以上`Test t2=t1;`即是此例。

**必须显式定义拷贝构造函数的情况**
对于拷贝来讲，尤其需要注意的即是`指针和动态分配的资源`，这些很容易造成拷贝变成`浅拷贝(指向复制前后的变量指向同一块内存区域)`。  
因此如果类的成员变量包含指针类型，或者有成员表示在构造函数中分配的其他资源，这两种情况下都必须显式的定义拷贝构造函数。

### 拷贝赋值运算符
通过定义`拷贝赋值运算符`，来实现类实例之间的`=`拷贝运算。  
拷贝赋值运算符的通常形式为
`classname& operator=(const classname& a)`

**拷贝赋值运算符与拷贝构造函数**
以下例来观察二者的不同：
```c++
Test t2 = t1; // 即上面的例子，调用的是拷贝构造函数，即在创建时进行初始化
Test t3;
t3 = t1;  // 此时调用拷贝赋值运算符，因为并不是在创建类的实例时进行初始化
```
可以看出二者之间有很大的共通性，即都是为了进行完整的复制/拷贝而创立的，防止陷入浅拷贝造成内存安全问题。

### C++11特性之default/delete
在未显式的定义类的特殊成员函数时，如果被调用，系统会自动隐式的创建该特殊成员函数，且`隐式的创建方式比显式的创建方式执行效率高`。

只需在函数声明后加上`=default;`，就可将该函数声明为 defaulted 函数，编译器将为显式声明的 defaulted 函数自动生成函数体，以获得更高的执行效率。

有些时候，我们需要禁用某些函数(`=delete`不仅可以禁用类内的特殊成员函数，也可以禁用一般函数)，此时就需要在该函数后面增加`=delete；`，则该函数将变的不可调用，比如不可复制等。

**sample**：
```c++
class Test{
    private:
        int _id;

    public:
        Test() = default; // 定义默认构造函数
        Test(int a);
        Test(const Test& test) = delete;  // 禁止使用拷贝构造函数的场景
        Test& operator=(const Test& test);
        ~Test(); 
}
```